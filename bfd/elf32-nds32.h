/* NDS32-specific support for 32-bit ELF.
   Copyright (C) 2012-2013 Free Software Foundation, Inc.
   Contributed by Andes Technology Corporation.

   This file is part of BFD, the Binary File Descriptor library.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.*/

#ifndef ELF32_NDS32_H
#define ELF32_NDS32_H

/*
 * Relocation flags encoded in r_addend.
 */

/* Relocation flags for R_NDS32_ERLAX_ENTRY.  */

/* Set if relax on this section is done or disabled.  */
#define R_NDS32_RELAX_ENTRY_DISABLE_RELAX_FLAG			(1 << 31)
/* Optimize for performance.  */
#define R_NDS32_RELAX_ENTRY_OPTIMIZE_FLAG			(1 << 30)
/* Optimize for size.  Branch destination 4-byte adjustment
   may be disabled.  */
#define R_NDS32_RELAX_ENTRY_OPTIMIZE_FOR_SPACE_FLAG		(1 << 29)
/* To distinguish the assembly code generated by compiler
   or written manually.  */
#define R_NDS32_RELAX_ENTRY_VERBATIM_FLAG			(1 << 28)
/* EX9 and link-time IFC must be explicitly enabled, so we
   won't mess up handcraft assembly code.  */
/* Enable EX9 optimization for this section.  */
#define R_NDS32_RELAX_ENTRY_EX9_FLAG				(1 << 2)
/* Enable IFC optimization for this section.  */
#define R_NDS32_RELAX_ENTRY_IFC_FLAG				(1 << 3)
/* Two bits for ICT to comply with files without directive.  */
/* ICT small model.  */
#define R_NDS32_RELAX_ENTRY_ICT_SMALL				(0x2 << 4)
/* ICT large model.  */
#define R_NDS32_RELAX_ENTRY_ICT_LARGE				(0x3 << 4)
/* Mask for get ict bits.  */
#define R_NDS32_RELAX_ENTRY_ICT_MASK				(0x3 << 4)


/* Relocation flags for R_NDS32_INSN16.  */

/* Tag the nop16 can be removed.  */
#define R_NDS32_INSN16_CONVERT_FLAG				(1 << 0)
/* Convert a gp-relative access (e.g., lwi.gp)
   to fp-as-gp access (lwi37.fp).
   This value is used by linker internally only.
   It's fine to change the vlaue.  */
#define R_NDS32_INSN16_FP7U2_FLAG				(1 << 1)

/* Relocation flags for R_NDS32_RELAX_REGION_OMIT_FP_START/END.  */

/* OMIT_FP_FLAG marks the region for applying fp-as-gp
   optimization.  */
#define R_NDS32_RELAX_REGION_OMIT_FP_FLAG			(1 << 0)
/* NOT_OMIT_FP_FLAG is set if this region is not worth
   for fp-as-gp.  */
#define R_NDS32_RELAX_REGION_NOT_OMIT_FP_FLAG			(1 << 1)
/* Suppress EX9 optimization in the region.  */
#define R_NDS32_RELAX_REGION_NO_EX9_FLAG			(1 << 2)
/* A Innermost loop region.  Some optimizations is suppressed
   in this region due to performance drop.  */
#define R_NDS32_RELAX_REGION_INNERMOST_LOOP_FLAG		(1 << 4)
/* Suppress IFC optimization in the region.  */
#define R_NDS32_RELAX_REGION_NO_IFC_FLAG			(1 << 5)

/* Tag range for LOADSTORE relocation.  */
enum
{
  NDS32_LOADSTORE_NONE = 0x0,
  NDS32_LOADSTORE_BYTE = 0x1,
  NDS32_LOADSTORE_HALF = 0x2,
  NDS32_LOADSTORE_WORD = 0x4,
  NDS32_LOADSTORE_FLOAT_S = 0x8,
  NDS32_LOADSTORE_FLOAT_D = 0x10,
  NDS32_LOADSTORE_IMM = 0x20
};

/* Relax tag for nds32_elf_relax_section, we have to specify which
   optimization do in this round.  */
enum
{
  NDS32_RELAX_NONE_ROUND = 0,
  NDS32_RELAX_NORMAL_ROUND,
  NDS32_RELAX_JUMP_IFC_ROUND,
  NDS32_RELAX_IFC_ROUND,
  NDS32_RELAX_EX9_BUILD_ROUND,
  NDS32_RELAX_EX9_REPLACE_ROUND,
  NDS32_RELAX_EMPTY_ROUND
};

/* Security tag.  */
enum
{
  NDS32_SECURITY_NONE = 0,
  NDS32_SECURITY_START,
  NDS32_SECURITY_RESTART,
  NDS32_SECURITY_END
};

/* There are two state in IFC optimization including general ifc (post-opt)
   and jump ifc (j and jal).  Therefore, we have to use two different mask to
   distinguish them.  */
/* Optimization status mask.  */
#define NDS32_RELAX_JUMP_IFC_DONE	(1 << 0)
#define NDS32_RELAX_EX9_DONE		(1 << 1)
#define NDS32_RELAX_IFC_DONE		(1 << 2)

/* Optimization turn on mask.  */
#define NDS32_RELAX_IFC_ON		(1 << 0)
#define NDS32_RELAX_EX9_ON		(1 << 1)

void nds32_insertion_sort
  (void *base, size_t nmemb, size_t size,
   int (*compar) (const void *lhs, const void *rhs));

struct section_id_list_t
{
  int id;
  struct section_id_list_t *next;
};

struct section_id_list_t *
  elf32_nds32_lookup_section_id (int id, struct section_id_list_t **lst_ptr);
int elf32_nds32_check_relax_group (bfd *bfd, asection *sec);
int elf32_nds32_unify_relax_group (bfd *abfd, asection *asec);
int nds32_elf_unify_tls_model (bfd *inbfd, asection *insec,
			       bfd_byte *incontents,
			       struct bfd_link_info *lnkinfo);

void bfd_elf32_nds32_set_target_option (struct bfd_link_info *, int, int,
					FILE *, int, int, int, int, char *,
					FILE *, int, int, bfd_boolean,
					bfd_boolean, bfd_boolean, int,
					bfd_boolean, bfd_boolean, bfd_boolean,
					char *, char *, int);
void bfd_elf32_nds32_append_section (struct bfd_link_info*, bfd *, int);
int nds32_convert_32_to_16
  (bfd *abfd, uint32_t insn, uint16_t *pinsn16, int *pinsn_type);
int nds32_convert_16_to_32 (bfd *abfd, uint16_t insn16, uint32_t *pinsn);

#define nds32_elf_hash_table(info) \
  (elf_hash_table_id ((struct elf_link_hash_table *) ((info)->hash)) \
   == NDS32_ELF_DATA ? ((struct elf_nds32_link_hash_table *) ((info)->hash)) : NULL)

#define elf32_nds32_compute_jump_table_size(htab) \
  ((htab)->next_tls_desc_index * 4)

#define elf32_nds32_local_tlsdesc_gotent(bfd) \
  (elf_nds32_tdata (bfd)->local_tlsdesc_gotent)

/* Hash table structure for target nds32.  There are some members to
   save target options passed from nds32elf.em to bfd.  */

struct elf_nds32_link_hash_table
{
  struct elf_link_hash_table root;

  /* ?? Short-cuts to get to dynamic linker sections.  */
  asection *sdynbss;
  asection *srelbss;

  /* Small local sym to section mapping cache.  */
  struct sym_cache sym_cache;

  /* Target dependent options.  */
  int relax_fp_as_gp;		/* --mrelax-omit-fp  */
  int eliminate_gc_relocs;	/* --meliminate-gc-relocs  */
  FILE *sym_ld_script;		/* --mgen-symbol-ld-script=<file>  */
  /* Disable if linking a dynamically linked executable.  */
  int load_store_relax;
  int target_optimize;		/* Switch optimization.  */
  int relax_status;		/* Finished optimization.  */
  int relax_round;		/* Going optimization.  */
  char *ex9_export_file;	/* --mexport-ex9=<file>  */
  FILE *ex9_import_file;	/* --mimport-ex9=<file>  */
  int update_ex9_table;		/* --mupdate-ex9.  */
  int keep_import_ex9;		/* --mkeep-import-ex9.  */
  int ex9_limit;
  bfd_boolean ex9_loop_aware;	/* Ignore ex9 if inside a loop.  */
  bfd_boolean ifc_loop_aware;	/* Ignore ifc if inside a loop.  */
  bfd_boolean hyper_relax;	/* Relax for symbol not in RW sections.  */
  int tls_desc_trampoline;	/* --m[no-]tlsdesc-trampoline.  */
  bfd_boolean ex9_ji_limit;	/* Limit JI instruction convertion.  */
  bfd_boolean ex9_noji;		/* Forbid JI instruction convert to ex9.  */
  bfd_boolean ex9_nols;		/* Forbid load-store instruction convert to ex9.  */
  char *isps_file_name;		/* --misps=<file>  */

  /* The offset into splt of the PLT entry for the TLS descriptor
   resolver.  Special values are 0, if not necessary (or not found
   to be necessary yet), and -1 if needed but not determined
   yet.  */
  bfd_vma dt_tlsdesc_plt;

  /* The offset into sgot of the GOT entry used by the PLT entry
   above.  */
  bfd_vma dt_tlsdesc_got;

  /* Offset in .plt section of tls_nds32_trampoline.  */
  bfd_vma tls_trampoline;

  /* The index of the next unused R_NDS32_TLS_DESC slot in .rel.plt.  */
  bfd_vma next_tls_desc_index;

  /* How many R_NDS32_TLS_DESC relocations were generated so far.  */
  bfd_vma num_tls_desc;

  /* The amount of space used by the reserved portion of the sgotplt
     section, plus whatever space is used by the jump slots.  */
  bfd_vma sgotplt_jump_table_size;

  /* True if the target uses REL relocations.  */
  int use_rel;
};
#endif
