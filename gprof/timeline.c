// ============================================================================
// timeline.c  -  Create timeline based profiling.
// Copyright 2006 Andes Technology Corporation
//
// This file is part of GNU Binutils. It is an extension to support timeline
// based profiling from data generated by Andes ISS.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 2 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
// 02111-1307, USA.
// ============================================================================
#define _LARGEFILE64_SOURCE
#include "gprof.h"
#include "search_list.h"
#include "source.h"
#include "symtab.h"
#include "cg_arcs.h"
#include "call_graph.h"
#include "corefile.h"
#include "gmon_io.h"
#include "prof_io.h"
#include "gmon_out.h"
#include "sym_ids.h"
#include "timeline.h"
#include <sys/types.h>
#include <unistd.h>

extern unsigned short min_function_level;
extern time_t TotalProfileTime, ReadProfOutDataTime, ParsingProfileDataTime, WriteTemplateFileTime, ReadTemplateFileTime, ProcessDataTime, WriteTimelineBinFileTime, StartTime, EndTime;

// Due to SID has the same symbol definition, so I change this definition from timeline.h into timeline.c and prof_io.c file.
enum{
	LOW_NIBBLE,
	HIGH_NIBBLE
}NIBBLE;

tcgheader tcghdr;       // report header
tcgfname *tcgfni=NULL;  // report function name index
char *tcgfnp=NULL;      // report function name pool
tcgpage *tcgpages=NULL; // report pages
tcgnode1 *tcgnodes1=NULL; // report call-graph arcs

#define u8 unsigned char

FILE * fop = NULL;

#ifdef TL_DEBUG
#define TimeLine2Text(data, len)	\
	{\
		int i;\
		if (fop == NULL) {					\
			fop = fopen("tv", "wb+");		\
											\
			for (i = 0; i <= 40; i++)		\
				fprintf(fop, "%02d ", i);	\
			fprintf(fop, "\n");				\
											\
			for (i = 0; i <= 40; i++)		\
				fprintf(fop, "---");		\
			fprintf(fop, "\n");				\
		}									\
											\
		for (i = 0; i < len; i++)			\
		{									\
			fprintf(fop, "%02x ", data[i]&0xff);	\
		}									\
		fprintf(fop, "\n");					\
	}
#else
	#define TimeLine2Text(data, len)
#endif


// =============================================================================
// calculate_data_size
//
// This function calculates length of data
// return:
// positive value:	data length
// -1:			parameter error
// =============================================================================
unsigned int
calculate_data_size(unsigned char size_info, int nibble)
{
	if(nibble == HIGH_NIBBLE){
		if((size_info & 0x80)){
			return 8;
		}else if((size_info & 0x40)){
			return 4;
		}else if((size_info & 0x20)){
			return 2;
		}else{
			return 1;
		}
	}else if(nibble == LOW_NIBBLE){
		if((size_info & 0x08)){
			return 8;
		}else if((size_info & 0x04)){
			return 4;
		}else if((size_info & 0x02)){
			return 2;
		}else{
			return 1;
		}
	}

	return -1;
}


int
getMsgLen(char *buf, int len)
{
	int ret = 0;
	int i;

	for (i = 0; i < len; i++)
	{
		ret += buf[i]&0xf;
		ret += (buf[i]>>4)&0xf;

	}
	return ret;
}

int
TimeLine_L1(FILE *fd)
{
	Sym *sym;
	Header_t	H;
	unsigned long length;
	char buf[256];
	char wbuf[512];
	char * wp;
	long pos, start_pos;
	int len1, len2;
	char onebyte[1];
	char threebyte[3];

	while (!feof(fd))
	{
		start_pos = ftell(fd);
		fread(&H, sizeof(Header_t), 1, fd);
		wp = wbuf;

		switch(H.tag) {
			case PROFTYPE_ON1:
			case PROFTYPE_FC1:
				fread(&length, 4, 1, fd);
				fread(onebyte, 1, 1, fd);
				len1 = getMsgLen(onebyte, 1);
				fread(buf, len1, 1, fd);

				pos = ftell(fd);
				fseek(fd, length, SEEK_SET);
//				fseek(fd, length - sizeof(Header_t) - 5 - len1, SEEK_CUR);

				fread(threebyte, 3, 1, fd);
				len2 = getMsgLen(threebyte, 3);
				fread(buf + len1, len2, 1, fd);
				fseek(fd, pos, SEEK_SET);

				length = length + 3 + len2 - start_pos;
//				length = length + 3 + len2;

				sym = sym_lookup(&symtab, H.func_id);
				H.func_id = (sym == NULL) ? 0 : sym - symtab.base;

				sym = sym_lookup(&symtab, H.parent_id);
				H.parent_id = (sym == NULL) ? 0 : sym - symtab.base;

				wp = mempcpy(wp, &H, sizeof(Header_t));
				wp = mempcpy(wp, &length, sizeof(length));
				wp = mempcpy(wp, onebyte, 1);
				wp = mempcpy(wp, threebyte, 3);
				wp = mempcpy(wp, buf, len1+len2);
				break;

			case PROFTYPE_FR1:
			case PROFTYPE_OFF:
			case PROFTYPE_DUMMY_FR1:
				fread(onebyte, 1, 1, fd);
				len1 = getMsgLen(onebyte, 1);
				fread(buf, len1, 1, fd);
				fread(threebyte, 3, 1, fd);
				len2 = getMsgLen(threebyte, 3);
				// skip the summary data
				fseek (fd, len2, SEEK_CUR);

				sym = sym_lookup(&symtab, H.func_id);
				H.func_id = (sym == NULL) ? 0 : sym - symtab.base;

				sym = sym_lookup(&symtab, H.parent_id);
				H.parent_id = (sym == NULL) ? 0 : sym - symtab.base;

				wp = mempcpy(wp, &H, sizeof(Header_t));
				wp = mempcpy(wp, onebyte, 1);
				wp = mempcpy(wp, buf, len1);
				break;
			default:
				break;
		}

		if (!fwrite(wbuf, wp-wbuf, 1, stdout))
		{
			gErrorCode = errno;
			return -1;
		}
		TimeLine2Text(wbuf, wp-wbuf);
		if (H.tag == PROFTYPE_OFF)
			break;
	}
	return 0;
}


int
TimeLine_L2(FILE *fd)
{
	Sym *sym;
	Header_t	H;
	unsigned long length;
	char buf[256];
	char wbuf[512];
	char * wp;
	long pos, start_pos;
	int len1, len2;
	char onebyte[1];
	char fivebytes[5];
	char branch;
	long reserved;

	while (!feof(fd))
	{
		start_pos = ftell(fd);
		fread(&H, sizeof(Header_t), 1, fd);
		wp = wbuf;

		switch(H.tag) {
			case PROFTYPE_ON2:
			case PROFTYPE_FC2:
				fread(&length, 4, 1, fd);
				fread(onebyte, 1, 1, fd);
				len1 = getMsgLen(onebyte, 1);
				fread(buf, len1, 1, fd);
				fread(&branch, 1, 1, fd);	// branch

				pos = ftell(fd);
				fseek(fd, length, SEEK_SET);

				{
					// skipping block..... to summary data
					Header_t	tmp_H;
					char 		tmp_onebyte[1];
					int			tmp_len;
					char		tmp_buf[20];


					fread(&tmp_H, sizeof(Header_t), 1, fd);
					fread(tmp_onebyte, 1, 1, fd);
					tmp_len = getMsgLen(tmp_onebyte, 1);
					fread(tmp_buf, tmp_len+1, 1, fd);
				}

				fread(fivebytes, 5, 1, fd);
				len2 = getMsgLen(fivebytes, 5);

				fread(buf + len1, len2, 1, fd);
				fseek(fd, pos, SEEK_SET);

				length = length + 5 + len2 - start_pos;

				sym = sym_lookup(&symtab, H.func_id);
				H.func_id = (sym == NULL) ? 0 : sym - symtab.base;

				sym = sym_lookup(&symtab, H.parent_id);
				H.parent_id = (sym == NULL) ? 0 : sym - symtab.base;

				wp = mempcpy(wp, &H, sizeof(Header_t));
				wp = mempcpy(wp, &length, sizeof(length));
				wp = mempcpy(wp, onebyte, 1);
				wp = mempcpy(wp, fivebytes, 5);
				wp = mempcpy(wp, buf, len1+len2);
				wp = mempcpy(wp, &branch, 1);
				break;

			case PROFTYPE_FR2:
			case PROFTYPE_OFF:
			case PROFTYPE_DUMMY_FR2:
				fread(onebyte, 1, 1, fd);
				len1 = getMsgLen(onebyte, 1);
				fread(buf, len1, 1, fd);
				fread(&branch, 1, 1, fd);	// branch

				fread(fivebytes, 5, 1, fd);
				len2 = getMsgLen(fivebytes, 5);
				// skip the summary data
				fseek (fd, len2, SEEK_CUR);

				sym = sym_lookup(&symtab, H.func_id);
				H.func_id = (sym == NULL) ? 0 : sym - symtab.base;

				sym = sym_lookup(&symtab, H.parent_id);
				H.parent_id = (sym == NULL) ? 0 : sym - symtab.base;

				wp = mempcpy(wp, &H, sizeof(Header_t));
				wp = mempcpy(wp, onebyte, 1);
				wp = mempcpy(wp, buf, len1);
				wp = mempcpy(wp, &branch, 1);
				break;

			case PROFTYPE_BR2:
				fread(onebyte, 1, 1, fd);
				len1 = getMsgLen(onebyte, 1);
				fread(buf, len1, 1, fd);
				fread(&branch, 1, 1, fd);	// branch
				fread(&reserved, 4, 1, fd);

				sym = sym_lookup(&symtab, H.func_id);
				H.func_id = (sym == NULL) ? 0 : sym - symtab.base;

				sym = sym_lookup(&symtab, H.parent_id);
				H.parent_id = (sym == NULL) ? 0 : sym - symtab.base;

				wp = mempcpy(wp, &H, sizeof(Header_t));
				wp = mempcpy(wp, onebyte, 1);
				wp = mempcpy(wp, buf, len1);
				wp = mempcpy(wp, &branch, 1);
				wp = mempcpy(wp, &reserved, 4);

				break;
			default:
				break;
		}

		if (!fwrite(wbuf, wp-wbuf, 1, stdout))
		{
			gErrorCode = errno;
			return -1;
		}
		TimeLine2Text(wbuf, wp-wbuf);
		if (H.tag == PROFTYPE_OFF)
			break;
	}
	return 0;
}


int
TimeLine_L6(FILE *fd)
{
	Sym *sym;
	Header_t	H;
	unsigned long length;
	char buf[256];
	char wbuf[512];
	char * wp;
	long pos, start_pos;
	int len1, len2;
	char onebyte[1];
	char fourbytes[4];

	while (!feof(fd))
	{
		start_pos = ftell(fd);
		fread(&H, sizeof(Header_t), 1, fd);
		wp = wbuf;

		switch(H.tag) {
			case PROFTYPE_ON6:
			case PROFTYPE_FC6:
				fread(&length, 4, 1, fd);
				fread(onebyte, 1, 1, fd);
				len1 = getMsgLen(onebyte, 1);
				fread(buf, len1, 1, fd);

				pos = ftell(fd);
				fseek(fd, length, SEEK_SET);
//				fseek(fd, length - sizeof(Header_t) - 5 - len1, SEEK_CUR);

				fread(fourbytes, 4, 1, fd);
				len2 = getMsgLen(fourbytes, 4);
				fread(buf + len1, len2, 1, fd);
				fseek(fd, pos, SEEK_SET);

				length = length + 4 + len2 - start_pos;
//				length = length + 3 + len2;

				sym = sym_lookup(&symtab, H.func_id);
				H.func_id = (sym == NULL) ? 0 : sym - symtab.base;

				sym = sym_lookup(&symtab, H.parent_id);
				H.parent_id = (sym == NULL) ? 0 : sym - symtab.base;

				wp = mempcpy(wp, &H, sizeof(Header_t));
				wp = mempcpy(wp, &length, sizeof(length));
				wp = mempcpy(wp, onebyte, 1);
				wp = mempcpy(wp, fourbytes, 4);
				wp = mempcpy(wp, buf, len1+len2);
				break;

			case PROFTYPE_FR6:
			case PROFTYPE_OFF:
			case PROFTYPE_DUMMY_FR6:
				fread(onebyte, 1, 1, fd);
				len1 = getMsgLen(onebyte, 1);
				fread(buf, len1, 1, fd);
				fread(fourbytes, 4, 1, fd);
				len2 = getMsgLen(fourbytes, 4);
				// skip the summary data
				fseek (fd, len2, SEEK_CUR);

				sym = sym_lookup(&symtab, H.func_id);
				H.func_id = (sym == NULL) ? 0 : sym - symtab.base;

				sym = sym_lookup(&symtab, H.parent_id);
				H.parent_id = (sym == NULL) ? 0 : sym - symtab.base;

				wp = mempcpy(wp, &H, sizeof(Header_t));
				wp = mempcpy(wp, onebyte, 1);
				wp = mempcpy(wp, buf, len1);
				break;
			default:
				break;
		}

		if (!fwrite(wbuf, wp-wbuf, 1, stdout))
		{
			gErrorCode = errno;
			return -1;
		}
		TimeLine2Text(wbuf, wp-wbuf);
		if (H.tag == PROFTYPE_OFF)
			break;
	}
	return 0;
}



int
TimeLine_L7(FILE *fd)
{
	Sym *sym;
	Header_t	H;
	unsigned long length;
	char buf[256];
	char wbuf[512];
	char * wp;
	long pos, start_pos;
	int len1, len2;
	char onebyte[1];
	char sixbytes[6];

	while (!feof(fd))
	{
		start_pos = ftell(fd);
		fread(&H, sizeof(Header_t), 1, fd);
		wp = wbuf;

		switch(H.tag) {
			case PROFTYPE_ON7:
			case PROFTYPE_FC7:
				fread(&length, 4, 1, fd);
				fread(onebyte, 1, 1, fd);
				len1 = getMsgLen(onebyte, 1);
				fread(buf, len1, 1, fd);

				pos = ftell(fd);
				fseek(fd, length, SEEK_SET);
//				fseek(fd, length - sizeof(Header_t) - 5 - len1, SEEK_CUR);

				fread(sixbytes, 6, 1, fd);
				len2 = getMsgLen(sixbytes, 6);
				fread(buf + len1, len2, 1, fd);
				fseek(fd, pos, SEEK_SET);

				length = length + 6 + len2 - start_pos;
//				length = length + 3 + len2;

				sym = sym_lookup(&symtab, H.func_id);
				H.func_id = (sym == NULL) ? 0 : sym - symtab.base;

				sym = sym_lookup(&symtab, H.parent_id);
				H.parent_id = (sym == NULL) ? 0 : sym - symtab.base;

				wp = mempcpy(wp, &H, sizeof(Header_t));
				wp = mempcpy(wp, &length, sizeof(length));
				wp = mempcpy(wp, onebyte, 1);
				wp = mempcpy(wp, sixbytes, 6);
				wp = mempcpy(wp, buf, len1+len2);
				break;

			case PROFTYPE_FR7:
			case PROFTYPE_OFF:
			case PROFTYPE_DUMMY_FR7:
				fread(onebyte, 1, 1, fd);
				len1 = getMsgLen(onebyte, 1);
				fread(buf, len1, 1, fd);
				fread(sixbytes, 6, 1, fd);
				len2 = getMsgLen(sixbytes, 6);
				// skip the summary data
				fseek (fd, len2, SEEK_CUR);

				sym = sym_lookup(&symtab, H.func_id);
				H.func_id = (sym == NULL) ? 0 : sym - symtab.base;

				sym = sym_lookup(&symtab, H.parent_id);
				H.parent_id = (sym == NULL) ? 0 : sym - symtab.base;

				wp = mempcpy(wp, &H, sizeof(Header_t));
				wp = mempcpy(wp, onebyte, 1);
				wp = mempcpy(wp, buf, len1);
				break;
			default:
				break;
		}

		if (!fwrite(wbuf, wp-wbuf, 1, stdout))
		{
			gErrorCode = errno;
			return -1;
		}
		TimeLine2Text(wbuf, wp-wbuf);
		if (H.tag == PROFTYPE_OFF)
			break;
	}
	return 0;
}

int
TimeLine_L8(FILE *fd)
{
	Sym *sym;
	Header_t	H;
	unsigned long length;
	char buf[256];
	char wbuf[512];
	char * wp;
	long pos, start_pos;
	int len1, len2;
	char onebyte[1];
	char sevenbytes[7];

	while (!feof(fd))
	{
		start_pos = ftell(fd);
		fread(&H, sizeof(Header_t), 1, fd);
		wp = wbuf;

		switch(H.tag) {
			case PROFTYPE_ON8:
			case PROFTYPE_FC8:
				fread(&length, 4, 1, fd);
				fread(onebyte, 1, 1, fd);
				len1 = getMsgLen(onebyte, 1);
				fread(buf, len1, 1, fd);

				pos = ftell(fd);
				fseek(fd, length, SEEK_SET);
//				fseek(fd, length - sizeof(Header_t) - 5 - len1, SEEK_CUR);

				fread(sevenbytes, 7, 1, fd);
				len2 = getMsgLen(sevenbytes, 7);
				fread(buf + len1, len2, 1, fd);
				fseek(fd, pos, SEEK_SET);

				length = length + 7 + len2 - start_pos;
//				length = length + 3 + len2;

				sym = sym_lookup(&symtab, H.func_id);
				H.func_id = (sym == NULL) ? 0 : sym - symtab.base;

				sym = sym_lookup(&symtab, H.parent_id);
				H.parent_id = (sym == NULL) ? 0 : sym - symtab.base;

				wp = mempcpy(wp, &H, sizeof(Header_t));
				wp = mempcpy(wp, &length, sizeof(length));
				wp = mempcpy(wp, onebyte, 1);
				wp = mempcpy(wp, sevenbytes, 7);
				wp = mempcpy(wp, buf, len1+len2);
				break;

			case PROFTYPE_FR8:
			case PROFTYPE_OFF:
			case PROFTYPE_DUMMY_FR8:
				fread(onebyte, 1, 1, fd);
				len1 = getMsgLen(onebyte, 1);
				fread(buf, len1, 1, fd);
				fread(sevenbytes, 7, 1, fd);
				len2 = getMsgLen(sevenbytes, 7);
				// skip the summary data
				fseek (fd, len2, SEEK_CUR);

				sym = sym_lookup(&symtab, H.func_id);
				H.func_id = (sym == NULL) ? 0 : sym - symtab.base;

				sym = sym_lookup(&symtab, H.parent_id);
				H.parent_id = (sym == NULL) ? 0 : sym - symtab.base;

				wp = mempcpy(wp, &H, sizeof(Header_t));
				wp = mempcpy(wp, onebyte, 1);
				wp = mempcpy(wp, buf, len1);
				break;
			default:
				break;
		}

		if (!fwrite(wbuf, wp-wbuf, 1, stdout))
		{
			gErrorCode = errno;
			return -1;
		}
		TimeLine2Text(wbuf, wp-wbuf);
		if (H.tag == PROFTYPE_OFF)
			break;
	}
	return 0;
}
typedef struct{
	char * ptr;
	int len;
}Segment;

int
TimeLine_L9(FILE *fd)
{
	Sym *sym;
	Header_t	H;
	unsigned long length;
	char buf[256];
	char buf2[256];
	char temp[512];
	char wbuf[512];
	char * wp;
	long pos, start_pos;
	int len1, len2;
	char fourbytes[4];
	char eightbytes[8];
	char bytes_12[12];
	char branch;
	long reserved;
	Segment	seg[4];

	while (!feof(fd))
	{
		start_pos = ftell(fd);
		fread(&H, sizeof(Header_t), 1, fd);
		wp = wbuf;

		switch(H.tag) {
			case PROFTYPE_ON9:
			case PROFTYPE_FC9:
				fread(&length, 4, 1, fd);
				fread(fourbytes, 1, 4, fd);
				len1 = getMsgLen(fourbytes, 4);
				len1++;	// and one more byte for BR
				fread(buf, len1, 1, fd);

				pos = ftell(fd);
				fseek(fd, length, SEEK_SET);

				{
					// skipping block..... to summary data
					Header_t	tmp_H;
					char		tmp_fourbytes[4];
					int 		tmp_len;
					char		tmp_buf[256];

					fread(&tmp_H, sizeof(Header_t), 1, fd);
					fread(tmp_fourbytes, 4, 1, fd);
					tmp_len = getMsgLen(tmp_fourbytes, 4);
					fread(tmp_buf, tmp_len+1, 1, fd);
				}

				fread(eightbytes, 8, 1, fd);
				len2 = getMsgLen(eightbytes, 8);
				fread(buf2, len2, 1, fd);
				fseek(fd, pos, SEEK_SET);

				length = length + 8 + len2 - start_pos;

				sym = sym_lookup(&symtab, H.func_id);
				H.func_id = (sym == NULL) ? 0 : sym - symtab.base;

				sym = sym_lookup(&symtab, H.parent_id);
				H.parent_id = (sym == NULL) ? 0 : sym - symtab.base;

				memcpy(&bytes_12[0], &fourbytes[0], 1);
				memcpy(&bytes_12[1], &eightbytes[0], 5);
				memcpy(&bytes_12[6], &fourbytes[1], 3);
				memcpy(&bytes_12[9], &eightbytes[5], 3);

				seg[0].ptr = buf;
				seg[0].len = getMsgLen(fourbytes, 1);

				seg[1].ptr = buf2;
				seg[1].len = getMsgLen(eightbytes, 5);

				seg[2].ptr = seg[0].ptr + seg[0].len;
				seg[2].len = len1 - seg[0].len;

				seg[3].ptr = buf2 + seg[1].len;
				seg[3].len = len2 - seg[1].len;

				wp = mempcpy(wp, &H, sizeof(Header_t));
				wp = mempcpy(wp, &length, sizeof(length));
				wp = mempcpy(wp, bytes_12, 12);
				wp = mempcpy(wp, seg[0].ptr, seg[0].len);
				wp = mempcpy(wp, seg[1].ptr, seg[1].len);
				wp = mempcpy(wp, seg[2].ptr, seg[2].len);
				wp = mempcpy(wp, seg[3].ptr, seg[3].len);
				break;

			case PROFTYPE_FR9:
			case PROFTYPE_OFF:
			case PROFTYPE_DUMMY_FR9:
				fread(fourbytes, 4, 1, fd);
				len1 = getMsgLen(fourbytes, 4);
				len1++;	// and one more byte for BR
				fread(buf, len1, 1, fd);

				fread(eightbytes, 8, 1, fd);
				len2 = getMsgLen(eightbytes, 8);
				// skip the summary data
				fseek (fd, len2, SEEK_CUR);

				sym = sym_lookup(&symtab, H.func_id);
				H.func_id = (sym == NULL) ? 0 : sym - symtab.base;

				sym = sym_lookup(&symtab, H.parent_id);
				H.parent_id = (sym == NULL) ? 0 : sym - symtab.base;

				wp = mempcpy(wp, &H, sizeof(Header_t));
				wp = mempcpy(wp, fourbytes, 4);
				wp = mempcpy(wp, buf, len1);
				break;

			case PROFTYPE_BR9:
				fread(fourbytes, 4, 1, fd);
				len1 = getMsgLen(fourbytes, 4);
				len1 += 5;	// branch + reserved
				fread(buf, len1, 1, fd);
//				fread(&branch, 1, 1, fd);	// branch
//				fread(&reserved, 4, 1, fd);	// reserved

				sym = sym_lookup(&symtab, H.func_id);
				H.func_id = (sym == NULL) ? 0 : sym - symtab.base;

				sym = sym_lookup(&symtab, H.parent_id);
				H.parent_id = (sym == NULL) ? 0 : sym - symtab.base;

				wp = mempcpy(wp, &H, sizeof(Header_t));
				wp = mempcpy(wp, fourbytes, 4);
				wp = mempcpy(wp, buf, len1);
				break;
			default:
				break;
		}

		if (!fwrite(wbuf, wp-wbuf, 1, stdout))
		{
			gErrorCode = errno;
			return -1;
		}
		TimeLine2Text(wbuf, wp-wbuf);
		if (H.tag == PROFTYPE_OFF)
			break;
	}
	return 0;
}



// ============================================================================
// print_cgtimeline
//
// This function prints the timeline based call graph. This requires raw data
// with tag GMON_TAG_TL_1, GMON_TAG_TL_2, or GMON_TAG_TL_3, GMON_TAG_TL_4,
// GMON_TAG_TL_5, GMON_TAG_TL_6, GMON_TAG_TL_7, GMON_TAG_TL_8, or GMON_TAG_TL_9.
// ============================================================================
int
print_cgtimeline (void)
{
	FILE *fd;
	int result = 0;
#ifdef SET_BINARY
    SET_BINARY(fileno(stdout));
#endif // SET_BINARY

    // write out control information
    if(!fwrite(&tcghdr,sizeof(tcgheader),1,stdout))
	{
		gErrorCode = errno;
		return -1;
	}

    if (tcghdr.func_cnt>0)
    {
        if(!fwrite(tcgfni,sizeof(tcgfname),tcghdr.func_cnt,stdout))
		{
				gErrorCode = errno;
				return -1;
		}
    }
    if (tcghdr.pool_size>0)
	{
        if(!fwrite(tcgfnp,sizeof(char),tcghdr.pool_size,stdout))
	{
			gErrorCode = errno;
			return -1;
	}
    }

    // write out timeline entries
    fd=fopen(prof_temp_file,"rb+");

	switch(tcghdr.timeline_level)
		{
			case 1:
				result = TimeLine_L1(fd);
				break;

			case 2:
				result = TimeLine_L2(fd);
				break;

			case 6:
				result = TimeLine_L6(fd);
				break;

			case 7:
				result = TimeLine_L7(fd);
				break;

			case 8:
				result = TimeLine_L8(fd);
				break;

			case 9:
				result = TimeLine_L9(fd);
				break;
			default:
				break;
		}
	fclose(fd);

	if (fop != NULL)
		fclose(fop);

	return result;

} // print_cgtimeline

// ============================================================================
// print_bbtimeline
//
// This function prints the timeline based branch coverage. This requires raw
// data with tag GMON_TAG_TL_2 or GMON_TAG_TL3.
// ============================================================================
void
print_bbtimeline (void)
{/*
  bfd_vma from_pc, self_pc;
  unsigned int count;

  if (gmon_io_read_vma (ifp, &from_pc)
      || gmon_io_read_vma (ifp, &self_pc)
      || gmon_io_read_32 (ifp, &count))
    {
      fprintf (stderr, _("%s: %s: unexpected end of file\n"),
	       whoami, filename);
      done (1);
    }

  DBG (SAMPLEDEBUG,
       printf ("[cg_read_rec] frompc 0x%lx selfpc 0x%lx count %lu\n",
	       (unsigned long) from_pc, (unsigned long) self_pc,
	       (unsigned long) count));
  // Add this arc:
  cg_tally (from_pc, self_pc, count);
*/} // print_bbtimeline

// ============================================================================
// print_cacheusage
//
// This function prints the timeline based instruction coverage. This requires
// raw data with tag GMON_TAG_TL3.
// ============================================================================
void
print_cacheusage (void)
{/*
  bfd_vma from_pc, self_pc;
  unsigned int count;

  if (gmon_io_read_vma (ifp, &from_pc)
      || gmon_io_read_vma (ifp, &self_pc)
      || gmon_io_read_32 (ifp, &count))
    {
      fprintf (stderr, _("%s: %s: unexpected end of file\n"),
	       whoami, filename);
      done (1);
    }

  DBG (SAMPLEDEBUG,
       printf ("[cg_read_rec] frompc 0x%lx selfpc 0x%lx count %lu\n",
	       (unsigned long) from_pc, (unsigned long) self_pc,
	       (unsigned long) count));
  // Add this arc
  cg_tally (from_pc, self_pc, count);
*/} // print_cacheusage
